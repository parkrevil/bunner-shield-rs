# 개발 구현 계획 (Rust 코어 라이브러리)

본 계획은 `POLICY.md`에 정의된 보안 정책을 Rust 코어 라이브러리 형태로 구현하기 위한 실제 개발 절차를 정리한 것입니다. 모든 섹션은 릴리스 우선순위(1단계 → 2단계 → 3단계)에 따라 정렬되어 있으며, 각 작업 단계는 관련 국제 표준과 브라우저 표준 정책을 근거로 작성했습니다.

## 아키텍처 원칙 (요구사항 검토 결과)
- **외부 프레임워크 배제**: 모든 구현 및 테스트는 표준 라이브러리와 자체 모듈만 사용하며, 특정 웹 프레임워크 의존성을 문서에서 완전히 제거했습니다. 독립 실행형 코어 라이브러리로 유지 가능합니다.
- **기능별 전용 모듈 디렉터리**: 각 보안 기능은 `src/<feature>/` 구조(예: `src/csp/`, `src/hsts/`)로 분리하고, 옵션/검증/테스트 자원을 모듈 내부에 배치합니다. 모듈 경계가 명확해 유지보수와 기능 토글이 용이합니다.

위 항목들은 구현 가능하며, 아래 세부 계획에 즉시 반영되었습니다.

## 테스트 규칙(범용)
1. 테스트 파일엔 주석을 남기지 않는다.
2. 절대 중복된 테스트를 작성하지 않는다.

## 통합 테스트 규칙
1. 기능 단위로 파일을 생성하며 파일명은 기능명으로 한다.
2. 테스트 케이스명은 BDD 패턴을 따른다. (given|should|it 등등 다양하게)_when_then 패턴으로 영어로 작성
3. AAA 패턴을 사용하고 하나의 테스트 함수는 하나의 시나리오만 포함한다.

## 유닛 테스트 규칙
모든 개발 작업은 아래 단위 테스트 규칙을 준수해야 합니다.

1. 외부 파일로 작성. 대상 파일과 동일한 디렉토리에 대상 파일명_test.rs 로 명명
2. mod 함수명 으로 함수명 단위 모듈화
3. 테스트 케이스명은 BDD 패턴을 따른다. (given|should|it 등등 다양하게)_when_then 패턴으로 영어로 작성
4. 모듈부터 테스트 케이스까지 최대 3뎁스
5. 테스트에 필요한 헬퍼나 유틸은 tests/common 에 있는 것을 최대한 활용한다.
6. 만약 필요한 헬퍼나 유틸이 이 없는 경우 중복을 피하여 추가하고, 만약 기존 헬퍼나 유틸의 기능이 조금 부족해서 사용하지 못하는 경우 기존 기능을 범용화하여 수정한다.
7. 테스트 케이스는 작고 빠르게 유지한다.
8. 테스트 케이스는 테스트 대상 함수의 순수 기능에 대한 테스트만 한다.(함수 내에서 호출하는 외부 기능 검증하지 않음)
9. 테스트 케이스는 기능, 에러 처리, 엣지 케이스를 엄격하고 광범위하게 작성한다.
10. AAA 패턴을 사용하고 하나의 테스트 함수는 하나의 시나리오만 포함한다.
11. 테스트 간 상태공유는 금지하고 독립성을 보장한다.
12. 중복 된 테스트는 최대한 지양해라
13. 단위 격리(Isolation) 원칙: 테스트 대상 로직 내에서 사용하는 외부 기능은 테스트 범위에 포함하지 않는다. 외부 기능에 의존하지 않고 테스트 대상의 로직만 엄격하게 테스트한다.


## 파이프라인 실행 순서 개요
| 순서 | 단계 | 기능 |
| --- | --- | --- |
| 18 | 3단계 | Clear-Site-Data |

## 18. Clear-Site-Data (선택)
- **목표**: 보안 사고 대응 시 상태 초기화 지원.
- **파이프라인 순서**: 18 (3단계)
- **정적 상수**: `const HEADER_CLEAR_SITE_DATA`, `const VALUE_CACHE`, `const VALUE_COOKIES`, `const VALUE_STORAGE`, `const VALUE_EXECUTION_CONTEXTS`
- **구현 작업**
  1. `src/clear_site_data/` 디렉터리에서 플래그 비트마스크(`CACHE`, `COOKIES`, `STORAGE`, `EXECUTION_CONTEXTS`)와 `ClearSiteDataOptions` 정의.
  2. `ClearSiteDataOptions`는 `cookies()`, `storage()`, `execution_contexts()` 등 체이닝 메서드를 제공하며, `validate()`에서 최소 한 개 이상의 플래그가 설정되었는지 확인합니다.
  3. `Shield::clear_site_data(options: ClearSiteDataOptions)` 체인 메서드는 HTTPS 환경 여부 확인(선택적 `enforce_https` 플래그) 후 헤더를 적용합니다.
- **주의/검증**: 전체 쿠키 삭제로 인한 세션 손실 경고를 문서에 강조.
- **참조 규격**: W3C Clear Site Data

---

## 19. 문서화 및 예제 코드 배포
- **목표**: 라이브러리 사용자를 위한 가이드 제공.
- **구현 작업**
  1. `examples/` 폴더에 순수 Rust `main` 예제(`shield_basic.rs`)를 추가하여 `Shield::new().content_security_policy(...).strict_transport_security(...)` 흐름을 시연합니다.
  2. `README.md`에 각 체인 메서드 사용법과 옵션 검증 규칙, `NormalizedHeaders` 개념을 요약합니다.
  3. `README.md`에 모든 기능이 기본 비활성화 상태임을 강조하고, 파이프라인 순서를 표로 정리합니다.
  4. `POLICY.md` ↔ `PLAN.md` ↔ 실제 코드 간 추적표를 도표로 제공.
- **주의/검증**: 브라우저 동작 설명은 최소화하고 헤더 설정 방법 중심으로 유지.
- **참조 규격**: Rustdoc Best Practices, Cargo Examples Guide

---

## 20. 릴리스 및 유지보수 절차
- **목표**: 릴리스 검증과 장기 유지 전략 확립.
- **구현 작업**
  1. `cargo-husky` 훅에 포맷/린트/테스트 자동 실행.
  2. `CHANGELOG.md`에 SemVer 준수 릴리스 노트 작성.
  3. 보안 이슈 대응 체계: 헤더 표준 업데이트 모니터링(WHATWG, W3C, RFC 편람).
- **주의/검증**: 호환성 파괴 변경 시 메이저 버전 증가.
- **참조 규격**: SemVer 2.0.0, Rust Security Advisory DB

---

**검증 체크리스트**
- [ ] 모든 1단계 기능 단위 테스트/프로퍼티 테스트 통과
- [ ] 문서 예제 코드가 최신 API와 일치
- [ ] 헤더 값 직렬화가 각 표준의 문법 요구사항을 충족
- [ ] CI 파이프라인에 릴리스 전 자동 검증 포함
